<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>===TP1===</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>

    <script type="module">
        //mmm
        var config = {
            type: Phaser.CANVAS,
            width: 800,
            height: 670,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: true
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var game = new Phaser.Game(config);

        var map;
        var tileset;
        var layer;
        var tilesize = 32;

        var player;
        //player é uma array
        //0 - o objeto em si
        //1 - a velocidade máxima do jogador
        //2 - Phaser.Point 
        var playerSpawn;
        var cursors;

        var zombies;
        var landmines;
        var coins;
        var exits;
        var helps;

        var hud
        var hearts = 3;
        var coinsRemaining;

        var gameOver = false;
        var text;

        function preload() {
            this.load.image('tiles', 'assets/textures32.png');
            this.load.tilemapTiledJSON('untitled', 'assets/untitled.json');
            this.load.image('twink', 'assets/twink.png')
            this.load.image('orb', 'assets/orb.png')
            this.load.spritesheet('coin', 'assets/coin.png', { frameWidth: 16 })
            this.load.image('bomb', 'assets/bomb.png');

        }

        function create() {
            map = this.make.tilemap({ key: 'untitled' })
            tileset = map.addTilesetImage('tiles', 'tiles');
            layer = map.createLayer('layer', tileset);

            map.setCollisionByProperty({ collides: true });


            //vai buscar o spawn do ficheiro do mapa
            playerSpawn = this.physics.add.existing(
                map.createFromObjects('playerSpawn', {
                    key: 'orb',
                    classType: Phaser.Physics.Arcade.Sprite
                })
                [0]);
            //ao criar o jogador, criamos uma array
            //1º elemento é a sprite
            //2º elemento é a velocidade desta criatura
            player = [this.physics.add.sprite(playerSpawn.x, playerSpawn.y, 'twink'), 300];
            player[0].setOrigin(0.5)
            this.physics.add.collider(player, layer)
            this.physics.add.overlap(player, playerSpawn, reachSpawn);
            playerSpawn.disableBody(true, true);

            cursors = this.input.keyboard.createCursorKeys();


            this.anims.create({
                key: 'spin',
                frames: this.anims.generateFrameNumbers('coin'),
                frameRate: 10,
                repeat: -1
            });

            coins = this.physics.add.group(
                map.createFromObjects('coins', {
                    key: 'coin',
                    classType: Phaser.Physics.Arcade.Sprite
                }));

            coins.children.iterate(coin => {
                coin.play('spin')
            })

            this.physics.add.overlap(player, coins, collectCoin);


            landmines = this.physics.add.group(
                map.createFromObjects('landmines', {
                    key: 'bomb',
                    classType: Phaser.Physics.Arcade.Sprite
                }));
            this.physics.add.collider(player, landmines, hitLandmine);


            this.cameras.main.setSize(800, 600);
            this.cameras.main.setPosition(0, 70);
            this.cameras.main.setBounds(0, 0, layer.width, layer.height);
            this.cameras.main.startFollow(player[0], false, 1, 1);
            this.cameras.main.roundPixels = true;

            //    this.minimap = this.cameras.add(100, 100, 200, 200).setZoom(0.1).setName('mini');
            //    this.minimap.setBackgroundColor(0x000000);
            //    this.minimap.scrollX = 1600;
            //    this.minimap.scrollY = 300;

            hud = this.cameras.add(0, 0, 800, 70).setScroll(0, -70).setName('hud');
            text = this.add.text(4, -66, 'balls', { font: '34px Courier', fill: '#ff6600' });

        }

        function update(time, delta) {
            if (!gameOver) {
                //snapToGrid(player[0].body)
                movePlayer()

                coinsRemaining = coins.countActive(true)
                if (coinsRemaining > 0) {
                    text.setText([
                        'vidas: ' + hearts,
                        'moedas restantes: ' + coins.countActive(true)
                    ]);
                } else {
                    text.setText([
                        'vidas: ' + hearts,
                        'Apanhaste todas! Volta ao centro!'
                    ]);
                }
            } else {
                return
            }
        }


        /*
        function snapToGrid(body){
            if(body.velocity.x == 0){
                body.center.x = Phaser.Math.RoundTo(body.center.x / tilesize, 0) * tilesize;
            }
            if(body.velocity.y == 0){
                body.center.y = Phaser.Math.RoundTo(body.center.y / tilesize, 0) * tilesize;
            }
        }
        */


        //ver se a personagem pode andar para o tile que está nesta direção (à esquerda, etc.)
        function checkDirection(entity, direction) {
            var relativeX = entity.body.x;
            var relativeY = entity.body.y;

            if (direction == Phaser.LEFT) relativeX -= tilesize;
            if (direction == Phaser.RIGHT) relativeX += tilesize;
            if (direction == Phaser.UP) relativeY -= tilesize;
            if (direction == Phaser.DOWN) relativeY += tilesize;

            if (getTileAtWorldXY(relativeX, relativeY).properties[0]) {

            }
        }
        //mover a personagem numa direção
        function movePlayer() {
            var speedX = 0, speedY = 0
            var speed = player[1];
            if (cursors.up.isDown) speedY -= speed;
            if (cursors.down.isDown) speedY += speed;
            if (cursors.left.isDown) speedX -= speed;
            if (cursors.right.isDown) speedX += speed;

            //se estiver próximo do centro do tile, parar
            //se não, continuar a mover
            //se estiver parado, fora do centro do tile, sem velocidade, e sem input, dá snap to grid
            //OU
            //se estiver a mover-se para longe do centro e não tiver input, snap to grid
            /*
            if(speedX == 0){
                if(Math.abs((player[0].x % tilesize) - (tilesize/2)) > (tilesize/8)){
                    speedX = player[0].body.velocity.x;
                }else{
                    speedX = 0;
                    player[0].x = Phaser.Math.RoundTo(player[0].x/tilesize +0.5) *tilesize;
                }
            }
            
            if(speedY == 0){
                if((Math.abs((player[0].body.y % tilesize) - tilesize/2)) < (tilesize/3)){
                    speedY = player[0].body.velocity.y;
                }else{
                    speedY = 0;
                    player[0].body.y = Phaser.Math.RoundTo(player[0].body.y / tilesize, 0) * tilesize;
                }
            }
            */

            player[0].setVelocity(speedX, speedY);
        }

        function collectCoin(player, coin) {
            coin.disableBody(true, true);
            if (coins.countActive(true) === 0) {
                playerSpawn.enableBody(false, playerSpawn.x, playerSpawn.y, true, true)
            }
        }

        function hitLandmine(player, landmine) {
            landmine.disableBody(true, true);

            hearts--;
        }

        function reachSpawn(player, playerSpawn) {
            if (coins.countActive(true) === 0) {
                coins.children.iterate(function (child) {

                    child.enableBody(false, child.x, child.y, true, true);

                });
                playerSpawn.disableBody(true, true);
            }
        }

    </script>

</body>

</html>